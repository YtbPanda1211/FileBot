module.exports.config = {
	name: "shortcut",
	version: "1.1.0",
	hasPermssion: 0,
	credits: "Niiozic",
	description: "d√πng -shortcut tag ƒë·ªÉ th√™m c√¢u tr·∫£ l·ªùi khi c√≥ ng∆∞·ªùi tag",
	commandCategory: "Box chat",
  usages: "[all/delete/empty/tag]",
	cooldowns: 0,
  images: [],
	dependencies: {
		"fs-extra": "",
        "path": ""
	}
}
let format_attachment = type=>({
  photo: 'png', video: 'mp4', audio: 'mp3', animated_image: 'gif',
})[type] || 'bin';

module.exports.onLoad = function () {
    const { existsSync, writeFileSync, mkdirSync, readFileSync } = global.nodemodule["fs-extra"];
    const { resolve } = global.nodemodule["path"];
    const path = resolve(__dirname, '..', 'events', "shortcut", "shortcutdata.json");
    const pathGif = resolve(__dirname, '..', 'events' ,"shortcut", "shortcut");

    if (!global.moduleData.shortcut) global.moduleData.shortcut = new Map();

    if (!existsSync(path)) writeFileSync(path, JSON.stringify([]), "utf-8");
    if (!existsSync(pathGif)) mkdirSync(pathGif, { recursive: true });

    const data = JSON.parse(readFileSync(path, "utf-8"));

    for (const threadData of data) global.moduleData.shortcut.set(threadData.threadID, threadData.shortcuts);

    return;
}

module.exports.handleEvent = async function ({ event, api, Users }) {
    const { threadID, messageID, body, senderID, mentions: Mentions ={}} = event;
    if (!global.moduleData.shortcut) global.moduleData.shortcut = new Map();
    if (!global.moduleData.shortcut.has(threadID)) return;
    let mentions = Object.keys(Mentions);
    const data = global.moduleData.shortcut.get(threadID);
		if(!body) return;
     if ((dataThread = mentions.length > 0?data.find(item=>typeof item.tag_id == 'string' && mentions.includes(item.tag_id)) :false )||( dataThread = data.find(item => (item.input||'').toLowerCase() == body.toLowerCase()))) {
        const { resolve } = global.nodemodule["path"];
        const { existsSync, createReadStream } = global.nodemodule["fs-extra"];
        ;
        //const path = resolve(__dirname, '..', 'events' ,"shortcut", "shortcut",`${dataThread.id}`);
        
    var object, output;
    var moment = require("moment-timezone");
    var time = moment.tz("Asia/Ho_Chi_Minh").format('HH:mm:ss | DD/MM/YYYY');
        var output = dataThread.output;
        if (/\{name}/g.test(output)) {
            const name = global.data.userName.get(senderID) || await Users.getNameUser(senderID);
  output = output.replace(/\{name}/g, name).replace(/\{time}/g, time);
        }
        
        if (dataThread.uri/*existsSync(path)*/) object = { body: output, attachment: /*createReadStream(path) */(await require('axios').get(dataThread.uri,{responseType:'stream'}).catch(e=>({data:void 0}))).data}
        else object = { body: output };
        
        return api.sendMessage(object, threadID, messageID);
}
}

module.exports.handleReply = async function ({ event = {}, api, handleReply }) {
    if (handleReply.author != event.senderID) return;
    const { readFileSync, writeFileSync, unlinkSync } = global.nodemodule["fs-extra"];
    const axios = require('axios');
  try{
    const { resolve } = global.nodemodule["path"];
    const { threadID, messageID, senderID, body } = event;
    const name = this.config.name;

    const path = resolve(__dirname, '..', 'events', "shortcut", "shortcutdata.json");

    switch (handleReply.type) {
        case "requireInput": {
            if (body.length == 0) return api.sendMessage("‚ùé C√¢u tr·∫£ l·ªùi kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng", threadID, messageID);
            const data = global.moduleData.shortcut.get(threadID) || [];
            if (data.some(item => item.input == body)) return api.sendMessage("‚ùé Input ƒë√£ t·ªìn t·∫°i t·ª´ tr∆∞·ªõc", threadID, messageID);
            api.unsendMessage(handleReply.messageID);
            return api.sendMessage("üìå Reply tin nh·∫Øn n√†y ƒë·ªÉ nh·∫≠p c√¢u tr·∫£ l·ªùi khi s·ª≠ d·ª•ng t·ª´ kh√≥a", threadID, function (error, info) {
                return global.client.handleReply.push({
                    type: "requireOutput",
                    name,
                    author: senderID,
                    messageID: info.messageID,
                    input: body
                });
            }, messageID);
        }
        case "requireOutput": {
            if (body.length == 0) return api.sendMessage("‚ùé C√¢u tr·∫£ l·ªùi kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng", threadID, messageID);
            api.unsendMessage(handleReply.messageID);
            return api.sendMessage("üìå Reply tin nh·∫Øn n√†y b·∫±ng t·ªáp video/·∫£nh/mp3/gif ho·∫∑c n·∫øu kh√¥ng c·∫ßn b·∫°n c√≥ th·ªÉ reply tin nh·∫Øn n√†y v√† nh·∫≠p 's'", threadID, function (error, info) {
                return global.client.handleReply.push({
                    type: "requireGif",
                    name,
                    author: senderID,
                    messageID: info.messageID,
                    input: handleReply.input,
                    output: body,
                    input_type: handleReply.input_type,
                    tag_id: handleReply.tag_id,
                });
            }, messageID);
        }
        case "requireGif": {
            let id = global.utils.randomString(10),uri;
            if ((event.attachments||[]).length > 0) {
              try {
              let atm_0 = event.attachments[0];
              id=id+'.'+format_attachment(atm_0.type);
                const pathGif = resolve(__dirname, '..', 'events' ,"shortcut", "shortcut", id);
                    //await global.utils.downloadFile(atm_0.url, pathGif);
                var options = {
            method: "POST",
            url: "https://api.imgur.com/3/image",
            headers: {
              Authorization: "Client-ID fc9369e9aea767c",
            },
            data: {
              image: atm_0.url,
            },
          };
          const res = await axios(options);
          var data = res.data.data;
           uri = data.link;
             // uri = (await require('axios').get('https://imgu.dcnam.repl.co/?'+atm_0.url)).data;
                } catch (e) {console.log(e); return api.sendMessage("‚ö†Ô∏è Kh√¥ng th·ªÉ t·∫£i file v√¨ url kh√¥ng t·ªìn t·∫°i ho·∫∑c bot ƒë√£ x·∫£y ra v·∫•n ƒë·ªÅ v·ªÅ m·∫°ng!", threadID, messageID); }
            }
            
            const readData = readFileSync(path, "utf-8");
            var data = JSON.parse(readData);
            var dataThread = data.find(item => item.threadID == threadID) || { threadID, shortcuts: [] };
            var dataGlobal = global.moduleData.shortcut.get(threadID) || [];
            const object = { id, input: handleReply.input, output: handleReply.output ,uri, input_type: handleReply.input_type, tag_id: handleReply.tag_id};

            dataThread.shortcuts.push(object);
            dataGlobal.push(object);

            if (!data.some(item => item.threadID == threadID)) data.push(dataThread);
            else {
                const index = data.indexOf(data.find(item => item.threadID == threadID));
                data[index] = dataThread;
            }

            global.moduleData.shortcut.set(threadID, dataGlobal);
            writeFileSync(path, JSON.stringify(data, null, 4), "utf-8");
            api.unsendMessage(handleReply.messageID);
            return api.sendMessage(`üìù ƒê√£ th√™m th√†nh c√¥ng shortcut m·ªõi, d∆∞·ªõi ƒë√¢y l√† ph·∫ßn t·ªïng qu√°t:\n\n- ID: ${id}\n- Input: ${handleReply.input}\n- Type: ${handleReply.input_type||'text'}\n- Output: ${handleReply.output}`, threadID, messageID);
        }
      case "delShortcut": {
        const splitBody = event.body
        const input = splitBody.match(/\d+/g).map(Number);
				const readData = readFileSync(path, "utf-8");
        var data = JSON.parse(readData);
        var dataThread = data.find(item => item.threadID == threadID);
				var inputDel = [], nums = 1, stt = 1;
        for(let num of input) {
        const index = num - (nums++)
        var dataGlobal = global.moduleData.shortcut.get(threadID) || [];
        const dataDel = dataThread.shortcuts[index]
				inputDel.push(`${num}. ${dataDel.input||`@{${global.data.userName.get(dataDel.tag_id)}}`}`);
        if(dataDel.id.includes('.')){
         /* const pathGif = resolve(__dirname, '..', 'events' ,"shortcut", "shortcut", dataDel.id);
          unlinkSync(pathGif,(err) => {
  if (err) throw err;
})*/
        }
        dataThread.shortcuts = dataThread.shortcuts.filter(item => item.output !== dataDel.output)
        dataGlobal = dataGlobal.filter(item => item.output !== dataDel.output)
        global.moduleData.shortcut.set(threadID, dataGlobal);
      }
				writeFileSync(path, JSON.stringify(data, null, 4), "utf-8");
        return api.sendMessage('‚úÖ ƒê√£ x√≥a th√†nh c√¥ng\n\n' + inputDel.join('\n'),threadID)
      }
    }
  }catch(e){
    console.log(e)
  }
}

module.exports.run = function ({ event, api, args }) {
  try{
    const { readFileSync, writeFileSync, existsSync } = global.nodemodule["fs-extra"];
    const { resolve } = global.nodemodule["path"];
    const { threadID, messageID, senderID, mentions = {} } = event;
    const name = this.config.name;

    const path = resolve(__dirname, '..', 'events', "shortcut", "shortcutdata.json");

    switch (args[0]) {
        case "remove":
        case "delete":
        case "del":
        case "-d": {
            const readData = readFileSync(path, "utf-8");
            var data = JSON.parse(readData);
            const indexData = data.findIndex(item => item.threadID == threadID);
            if (indexData == -1) return api.sendMessage("‚ùé hi·ªán t·∫°i nh√≥m c·ªßa b·∫°n ch∆∞a c√≥ shortcut n√†o ƒë∆∞·ª£c set", threadID, messageID);
            var dataThread = data.find(item => item.threadID == threadID) || { threadID, shortcuts: [] };
            var dataGlobal = global.moduleData.shortcut.get(threadID) || [];
            var indexNeedRemove;

            if (dataThread.shortcuts.length == 0) return api.sendMessage("‚ùé hi·ªán t·∫°i nh√≥m c·ªßa b·∫°n ch∆∞a c√≥ shortcut n√†o ƒë∆∞·ª£c set", threadID, messageID);
/*
            if (isNaN(args[1])) indexNeedRemove = args[1];
            else indexNeedRemove = dataThread.shortcuts.findIndex(item => item.input == (args.slice(1, args.length)).join(" ") || item.id == (args.slice(1, args.length)).join(" "));
            
            dataThread.shortcuts.splice(indexNeedRemove, 1);
            dataGlobal.splice(indexNeedRemove, 1);
*/
            let rm = args.slice(1).map($=>+($-1)).filter(isFinite);
            
            dataThread.shortcuts = dataThread.shortcuts.filter(($,i)=>!rm.includes(i));
            dataGlobal = dataGlobal.filter(($,i)=>!rm.includes(i));
            global.moduleData.shortcut.set(threadID, dataGlobal);
            data[indexData] = dataThread;
            writeFileSync(path, JSON.stringify(data, null, 4), "utf-8");

            return api.sendMessage("‚úÖ ƒê√£ x√≥a th√†nh c√¥ng\n\n", threadID, messageID);
        }

        case "list":
        case "all":
        case "-a": {
            const data = global.moduleData.shortcut.get(threadID) || [];
            var array = [];
            if (data.length == 0) return api.sendMessage("‚ùé hi·ªán t·∫°i nh√≥m c·ªßa b·∫°n ch∆∞a c√≥ shortcut n√†o ƒë∆∞·ª£c set", threadID, messageID);
            else {
                var n = 1;
                for (const single of data) {
                    //const path = resolve(__dirname, '..', 'events' ,"shortcut", "shortcut",`${single.id}`);
                    //var existPath = false;
                    //if (existsSync(path)) existPath = true;
                    array.push(`${n++}. ${single.uri ? "yes" : "no"} ‚Ä¢ ${single.input_type == 'tag' ? `@{${global.data.userName.get(single.tag_id)}}`: single.input} -> ${single.output}`);
                }
                return api.sendMessage(`üìù D∆∞·ªõi ƒë√¢y l√† to√†n b·ªô shortcut nh√≥m c√≥:\n\n${array.join("\n")}\n\n'yes' l√† c√≥ t·ªáp g·ª≠i k√®m\n'no' l√† kh√¥ng c√≥ t·ªáp g·ª≠i k√®m\n\nReply (ph·∫£n h·ªìi) theo stt ƒë·ªÉ x√≥a shortcut`, threadID, function (error, info) {
                 global.client.handleReply.push({
                    type: "delShortcut",
                    name,
                    author: senderID,
                    messageID: info.messageID
                });
            });
            }
        }
        case 'tag': {
            let tag_id = Object.keys(mentions)[0] || senderID;
            
            const data = global.moduleData.shortcut.get(threadID) || [];
            if (data.some(item => item.tag_id == tag_id)) return api.sendMessage("‚ùé tag ƒë√£ t·ªìn t·∫°i t·ª´ tr∆∞·ªõc", threadID, messageID);
            
            api.sendMessage("üìå Reply tin nh·∫Øn n√†y ƒë·ªÉ nh·∫≠p c√¢u tr·∫£ l·ªùi khi ƒë∆∞·ª£c tag", threadID, function (error, info) {
                 global.client.handleReply.push({
                    type: "requireOutput",
                    name,
                    author: senderID,
                    messageID: info.messageID,
                    input_type: 'tag',
                    tag_id,
                });
            }, messageID);
        };
            break;
        default: {
            return api.sendMessage("üìå Reply tin nh·∫Øn n√†y ƒë·ªÉ nh·∫≠p t·ª´ kh√≥a cho shortcut", threadID, function (error, info) {
                return global.client.handleReply.push({
                    type: "requireInput",
                    name,
                    author: senderID,
                    messageID: info.messageID
                });
            }, messageID);
        }
    }

  }catch(e){
    console.log(e)
   }
}
